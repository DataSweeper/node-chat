'use strict';


var internalCommands = [
  '_executeQueryCommand',
  '_executeInsertCommand',
  '_executeUpdateCommand',
  '_executeRemoveCommand'
];

var commandMap = {
  '_executeQueryCommand': 'find',
  '_executeInsertCommand': 'insert',
  '_executeUpdateCommand': 'update',
  '_executeRemoveCommand': 'remove'
};



function MongodbProbe(agent) {
  this.agent = agent;

  this.packages = ['mongodb'];
}
exports.MongodbProbe = MongodbProbe;



MongodbProbe.prototype.attach = function(obj) {
  var self = this;

  if(obj.__appdynamicsProbeAttached__) return;
  obj.__appdynamicsProbeAttached__ = true;

  var proxy = self.agent.proxy;
  var profiler = self.agent.profiler;


  internalCommands.forEach(function(internalCommand) {
    var commandName = commandMap[internalCommand] || internalCommand;

    proxy.before(obj.Db.prototype, internalCommand, function(obj, args) {
      var command = (args && args.length > 0) ? args[0] : undefined;
      var commandArgs;
      var exitCall;
      var time;

      if(command && command.db) {
        var serverPool = self.getServerPool(command.db);
        var category;

        if (serverPool.length) {
          commandArgs = {
            databaseName: command.db.databaseName,
            collectionName: command.collectionName,
            query: command.query ? profiler.truncate(JSON.stringify(command.query)) : '',
            queryOptions: command.queryOptions,
            numberToSkip: command.numberToSkip,
            numberToReturn: command.numberToReturn
          };

          if(command.db.auths && command.db.auths.length > 0) {
            commandArgs.auth = command.db.auths[0];
          }

          if(internalCommand === '_executeQueryCommand') {
            category = "read";
          }
          else {
            category = "write";
          }

          time = profiler.time();

          var props = {
            'SERVER POOL': serverPool.join('\n'),
            DATABASE : commandArgs.databaseName,
            VENDOR : "MONGODB"
          };

          exitCall = profiler.createExitCall(time, {
            exitType: 'EXIT_DB',
            backendConfig: {
              customConfig: false
            },
            backendName: 'MongoDB',
            identifyingProperties: props,
            category: category,
            command: commandName,
            commandArgs: commandArgs,
            stackTrace: profiler.stackTrace(),
            label: serverPool[serverPool.length - 1] + ' - MONGODB',
            vendor: "MONGODB"
          });
        }
      }

      proxy.callback(args, -1, function(obj, args) {
        if (exitCall) {
          if(!time.done()) return;
          var error = proxy.getErrorObject(args);
          profiler.addExitCall(time, exitCall, error);
        }
      });
    });
  });
};

MongodbProbe.prototype.getServerPool = function(db) {
  var serverPool = [];

    var serverConfig = db.serverConfig;
    if(serverConfig) {
      if(serverConfig.host && serverConfig.port) {
        serverPool.push(serverConfig.host + ':' + serverConfig.port);
      }
      else if(Array.isArray(serverConfig.servers)) {
        serverConfig.servers.forEach(function(server) {
          serverPool.push(server.host + ':' + server.port);
        });
      }
    }

    if (serverPool.length) {
      serverPool = serverPool.sort();
    }

    return serverPool;
};
